# MIT License
# 
# Copyright (c) 2021 Martin Macecek
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

AWSTemplateFormatVersion: 2010-09-09
Description: Prerequisistes for CD Pipelines

# -----------------------------------------------------------------------------
# Parameters
# -----------------------------------------------------------------------------
Parameters:
  WebHookUrl:
    Description: The Webhook URL
    Type: String
    Default: ''
  ResourcePrefix:
    Description: The prefix for all resources
    Type: 'AWS::SSM::Parameter::Value<String>'
    Default: /CD/ResourcePrefix
    AllowedValues:
      - /CD/ResourcePrefix
  DeleteBucketContentLambdaArn:
    Description: The ARN of the DeleteBucketContent Lambda function
    Type: 'AWS::SSM::Parameter::Value<String>'
    Default: /Lambda/DeleteBucketContentLambda/Arn
    AllowedValues:
      - /Lambda/DeleteBucketContentLambda/Arn
  ArtifactBucketNameId:
    Description: The configurable part of the Artifact Bucket Name
    Type: 'AWS::SSM::Parameter::Value<String>'
    Default: /S3/ArtifactBucketNameId
    AllowedValues:
      - /S3/ArtifactBucketNameId
  CodeCommitAccount:
    Description: The CodeCommit Account Parameter
    Type: 'AWS::SSM::Parameter::Value<String>'
    Default: /CD/CodeCommitAccount
    AllowedValues:
      - /CD/CodeCommitAccount  
  ArmSupportedRegion:
    Description: The ARM Supported Region parameter
    Type: 'AWS::SSM::Parameter::Value<String>'
    Default: /CD/IsArmSupportedRegion
    AllowedValues:
      - /CD/IsArmSupportedRegion
 
# -----------------------------------------------------------------------------
# Conditions
# -----------------------------------------------------------------------------
Conditions:
  IsCrossAccountCodeCommit: !And [!Not [!Equals [!Ref CodeCommitAccount, '']], !Not [!Equals [!Ref CodeCommitAccount, !Ref AWS::AccountId]]]
  IsArmSupportedRegion: !Equals ['True', !Ref ArmSupportedRegion]

# -----------------------------------------------------------------------------
# Resources
# -----------------------------------------------------------------------------
Resources: 
  GetKmsKeyArnLambdaRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Replacement not necessary"
    Properties:
      RoleName: !Sub '${ResourcePrefix}GetKmsKeyArnRole'
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: !Sub '${ResourcePrefix}GetKmsKeyArnPolicy'
          PolicyDocument:
            Id: !Sub '${ResourcePrefix}GetKmsKeyArnPolicyDocument'
            Version: 2012-10-17
            Statement:
              - Sid: Logging
                Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              - Sid: ReadKmsKey
                Effect: Allow
                Action:
                  - 'kms:DescribeKey'
                Resource: !Sub 'arn:aws:kms:*:${AWS::AccountId}:key/*'
  GetKmsKeyArnLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "No critical data in log group"
    Properties:
      RetentionInDays: 1
      LogGroupName: !Sub '/aws/lambda/${ResourcePrefix}GetKmsKeyArn'
  GetKmsKeyArn:
    Type: AWS::Lambda::Function
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "No need for VPC here"
          - id: W92
            reason: "No concurrency needed"
    DependsOn: GetKmsKeyArnLogGroup
    Properties:
      FunctionName: !Sub '${ResourcePrefix}GetKmsKeyArn'
      Architectures: 
        - !If 
          - IsArmSupportedRegion
          - arm64
          - x86_64
      Code: 
        ZipFile: |
          import boto3, logging
          import cfnresponse
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info("event: {}".format(event))
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event['LogicalResourceId'])
                  else:
                      resourceProperties = event['ResourceProperties']
                      region = None
                      if "Region" in resourceProperties:
                          region = resourceProperties['Region']

                      keyId = event['ResourceProperties']['KeyId']
                      kms_client = boto3.client('kms', region_name=region)

                      response = kms_client.describe_key(KeyId=keyId)
                      kmsKeyArn = response['KeyMetadata']['Arn']
                      logger.info(f"KMS Key ARN: {kmsKeyArn}")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {"KmsKeyArn": kmsKeyArn}, event['LogicalResourceId'])
              except Exception as e:
                  logger.info("Exception: {}".format(e))
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, event['LogicalResourceId'])

      Handler: "index.lambda_handler"
      Runtime: python3.9
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt GetKmsKeyArnLambdaRole.Arn

  GetHostedZoneIdLambdaRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W11
            reason: "Route53 only supports all resources"
          - id: W28
            reason: "Replacement not necessary"
    Properties:
      RoleName: !Sub '${ResourcePrefix}GetHostedZoneIdRole'
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: !Sub '${ResourcePrefix}GetHostedZoneIdPolicy'
          PolicyDocument:
            Id: !Sub '${ResourcePrefix}GetHostedZoneIdPolicyDocument'
            Version: 2012-10-17
            Statement:
              - Sid: Logging
                Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              - Sid: ReadRoute53
                Effect: Allow
                Action:
                  - 'route53:ListHostedZonesByName'
                Resource: '*'
  GetHostedZoneIdLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "No critical data"
    Properties:
      RetentionInDays: 1
      LogGroupName: !Sub '/aws/lambda/${ResourcePrefix}GetHostedZoneId'
  GetHostedZoneId:
    Type: AWS::Lambda::Function
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "No need for VPC here"
          - id: W92
            reason: "No concurrency needed"
    DependsOn: GetHostedZoneIdLogGroup
    Properties:
      FunctionName: !Sub  '${ResourcePrefix}GetHostedZoneId'
      Architectures: 
        - !If 
          - IsArmSupportedRegion
          - arm64
          - x86_64
      Code: 
        ZipFile: |
          import boto3, logging
          import cfnresponse
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info("event: {}".format(event))
              try:
                  if event['RequestType'] == 'Delete':
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event['LogicalResourceId'])
                  else:
                      resourceProperties = event['ResourceProperties']
                      dnsName = event['ResourceProperties']['DnsName']
                      route53_client = boto3.client('route53')

                      response = route53_client.list_hosted_zones_by_name(DNSName=dnsName)
                      hostedZoneId = response['HostedZones'][0]['Id'].split("/")[-1]
                      logger.info(f"Hosted zone ID: {hostedZoneId}")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {"HostedZoneId": hostedZoneId}, event['LogicalResourceId'])
              except Exception as e:
                  logger.info("Exception: {}".format(e))
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, event['LogicalResourceId'])

      Handler: "index.lambda_handler"
      Runtime: python3.9
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt GetHostedZoneIdLambdaRole.Arn
  
  SourceBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ResourcePrefix}cd-sourcebucket-${AWS::AccountId}-${AWS::Region}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
        - ServerSideEncryptionByDefault:
            SSEAlgorithm: AES256
      VersioningConfiguration: 
        Status: Enabled
      LifecycleConfiguration:
        Rules:
        - Id: Put everything into STANDARD_IA after 30 days
          Transitions:
          - StorageClass: STANDARD_IA
            TransitionInDays: 30
          Status: Enabled
  DeleteContentFromSourceBucket:  
    Type: Custom::DeleteContentFromSourceBucket
    Properties:
      ServiceToken: !Ref DeleteBucketContentLambdaArn
      BucketName: !Ref SourceBucket
  CodePipelineApprovelSNSTopic:
    Type: AWS::SNS::Topic
    Properties:
      TopicName: !Sub ${ResourcePrefix}CD-CodePipeline-Approval-Topic
      Subscription:
        - Endpoint: !GetAtt ApprovalCdTeams.Arn
          Protocol: lambda
  CodePipelineApprovalSNSTopicPolicy:
    Type: AWS::SNS::TopicPolicy
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: F18
            reason: "Sufficiently limited by condition"
    Properties: 
      PolicyDocument: 
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              AWS: '*'
            Action: 
              - SNS:GetTopicAttributes
              - SNS:SetTopicAttributes
              - SNS:AddPermission
              - SNS:RemovePermission
              - SNS:DeleteTopic
              - SNS:Subscribe
              - SNS:ListSubscriptionsByTopic
              - SNS:Publish
              - SNS:Receive
            Resource: !Ref CodePipelineApprovelSNSTopic
            Condition:
              StringEquals:
                AWS:SourceOwner: !Sub '${AWS::AccountId}'
          - Sid: Allow_Publish_Events
            Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sns:Publish
            Resource: !Ref CodePipelineApprovelSNSTopic
      Topics: 
        - !Ref CodePipelineApprovelSNSTopic
  # TODO: Consider moving to 001 template
  CodePipelineServiceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ResourcePrefix}CD-${AWS::Region}-CodePipelineServiceRole'
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - codepipeline.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: !Sub '${ResourcePrefix}CD-${AWS::Region}-CodePipelineServicePolicy'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action:
                  - codecommit:CancelUploadArchive
                  - codecommit:GetBranch
                  - codecommit:GetCommit
                  - codecommit:GetUploadArchiveStatus
                  - codecommit:UploadArchive
                Resource: '*'
              - Effect: Allow
                Action:
                  - codedeploy:CreateDeployment
                  - codedeploy:GetApplicationRevision
                  - codedeploy:GetDeployment
                  - codedeploy:GetDeploymentConfig
                  - codedeploy:RegisterApplicationRevision
                Resource: '*'
              - Effect: Allow
                Action:
                  - codebuild:BatchGetBuilds
                  - codebuild:StartBuild
                Resource: '*'
              - Effect: Allow
                Action:
                  - devicefarm:ListProjects
                  - devicefarm:ListDevicePools
                  - devicefarm:GetRun
                  - devicefarm:GetUpload
                  - devicefarm:CreateUpload
                  - devicefarm:ScheduleRun
                Resource: '*'
              - Effect: Allow
                Action:
                  - lambda:InvokeFunction
                  - lambda:ListFunctions
                Resource: '*'
              - Effect: Allow
                Action:
                  - iam:PassRole
                  - sns:Publish
                Resource: '*'
              - Effect: Allow
                Action:
                  - elasticbeanstalk:*
                  - ec2:*
                  - elasticloadbalancing:*
                  - autoscaling:*
                  - cloudwatch:*
                  - s3:*
                  - sns:*
                  - cloudformation:*
                  - rds:*
                  - sqs:*
                  - ecs:*
                  - states:*
                Resource: '*'
              - !If 
                - IsCrossAccountCodeCommit
                - Effect: Allow
                  Resource:
                    - !Sub 'arn:aws:iam::${CodeCommitAccount}:role/*'
                    # - !Sub 'arn:aws:iam::${CodeCommitAccount}:role/${ResourcePrefix}CD-${AWS::Region}-CodePipelineServiceRole'
                  Action: sts:AssumeRole
                - !Ref AWS::NoValue
  CodePipelineCloudFormationDeployRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ResourcePrefix}CD-${AWS::Region}-CodePipelineCfnDeployRole'
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal:
              Service: cloudformation.amazonaws.com
      Path: /
  CodePipelineCloudFormationDeployRolePolicy:
    Type: AWS::IAM::Policy
    Properties:
      PolicyName: !Sub '${ResourcePrefix}CD-${AWS::Region}-CodePipelineCfnDeployPolicy'
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: '*'
            Resource: '*'
      Roles: 
      - !Ref CodePipelineCloudFormationDeployRole
  CodeBuildProjectRole:
    Type: AWS::IAM::Role
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Complies with Coding Guidelines"
    Properties:
      RoleName: !Sub '${ResourcePrefix}CD-${AWS::Region}-CodeBuildRole'
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Action: sts:AssumeRole
            Principal: 
              Service: codebuild.amazonaws.com
      Path: /
  CodeBuildProjectRolePolicy:
    Type: AWS::IAM::Policy
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: F4
            reason: "Complies with Coding Guidelines"
          - id: W12
            reason: "Complies with Coding Guidelines"
    Properties:
      PolicyName: !Sub '${ResourcePrefix}CD-${AWS::Region}-CodeBuildPolicy'
      PolicyDocument:
        Version: 2012-10-17
        Statement:
          # Access to Artifacts Store and Global Install Files Bucket
          - Effect: Allow
            Action:
              - s3:PutObject
              - s3:GetBucketPolicy
              - s3:GetObject
              - s3:ListBucket
            Resource:
              - !Sub 'arn:aws:s3:::${ResourcePrefix}${ArtifactBucketNameId}-${AWS::AccountId}-*'
              - !Sub 'arn:aws:s3:::${ResourcePrefix}${ArtifactBucketNameId}-${AWS::AccountId}-*/*'
          - Effect: Allow
            Action:
              - kms:Encrypt
              - kms:Decrypt
              - kms:ReEncrypt*
              - kms:GenerateDataKey*
              - kms:DescribeKey
              - kms:ListAliases*
              - kms:ListKeys*
            Resource: 
              - !Sub arn:aws:kms:*:${AWS::AccountId}:key/*
          - Effect: Allow
            Action:
              - kms:ListAliases
              - kms:ListKeys
            Resource: '*'
          # Access to the CloudFormation repository
          - Effect: Allow
            Action:
              - cloudformation:ValidateTemplate
            Resource: '*'
          # Access to CodeCommit 
          - Effect: Allow
            Action:
              - codecommit:BatchGetRepositories
              - codecommit:Get*
              - codecommit:GitPull
              - codecommit:List*
              - codecommit:CancelUploadArchive
              - codecommit:UploadArchive
            Resource: '*'
          # Access to Cloudwatch Logs
          - Effect: Allow
            Action:
              - logs:CreateLogGroup
              - logs:CreateLogStream
              - logs:PutLogEvents
              - logs:DescribeLogGroups
            Resource: arn:aws:logs:*:*:*
          # Reports
          - Effect: Allow
            Action:
              - codebuild:CreateReportGroup
              - codebuild:CreateReport
              - codebuild:UpdateReport
              - codebuild:BatchPutTestCases
              - codebuild:BatchPutCodeCoverages
            Resource: !Sub arn:aws:codebuild:*:${AWS::AccountId}:report-group/*
          # SSM
          - Effect: Allow
            Action:
              - ssmmessages:CreateControlChannel
              - ssmmessages:CreateDataChannel
              - ssmmessages:OpenControlChannel
              - ssmmessages:OpenDataChannel
            Resource: '*'
      Roles:
        - !Ref CodeBuildProjectRole
  AmazonCloudWatchEventRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - events.amazonaws.com
            Action: sts:AssumeRole
      Path: /
      Policies:
        - PolicyName: !Sub '${ResourcePrefix}StartPipelineExecution'
          PolicyDocument:
            Version: 2012-10-17
            Statement:
              - Effect: Allow
                Action: codepipeline:StartPipelineExecution
                Resource: !Sub 'arn:aws:codepipeline:${AWS::Region}:${AWS::AccountId}:*'
  
  CloudTrail:
    Type: AWS::CloudTrail::Trail
    Properties:
      TrailName: !Sub '${AWS::StackName}-CodepipelineTrail'
      IsLogging: true
      EnableLogFileValidation: true
      EventSelectors:  
        - DataResources:
            - Type: AWS::S3::Object
              Values: 
                - !Sub '${SourceBucket.Arn}/'
          IncludeManagementEvents: false
          ReadWriteType: WriteOnly
      IsMultiRegionTrail: true
      IncludeGlobalServiceEvents: true
      S3BucketName: !Ref CodePipelineTrailBucket
      CloudWatchLogsLogGroupArn: !GetAtt CloudWatchLogGroupCloudTrail.Arn
      CloudWatchLogsRoleArn: !GetAtt IamRoleForCwLogsCloudTrail.Arn
    DependsOn: "S3BucketPolicy"
  CodePipelineTrailBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ResourcePrefix}cd-ctbucket-${AWS::AccountId}-${AWS::Region}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
        - ServerSideEncryptionByDefault:
            SSEAlgorithm: AES256
      LifecycleConfiguration:
        Rules:
        - Id: Put everything into STANDARD_IA after 90 days
          Transitions:
          - StorageClass: STANDARD_IA
            TransitionInDays: 30
          Status: Enabled  
  DeleteContentFromCodePipelineTrailBucket:
    Type: Custom::DeleteContentFromCodePipelineTrailBucket
    Properties:
      ServiceToken: !Ref DeleteBucketContentLambdaArn
      BucketName: !Ref CodePipelineTrailBucket
  S3BucketPolicy:
    Type: "AWS::S3::BucketPolicy"
    Properties:
      Bucket: !Ref CodePipelineTrailBucket
      PolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Sid: AWSCloudTrailBucketPermissionsCheck
            Effect: Allow
            Principal:
              Service:
                - cloudtrail.amazonaws.com
            Action: s3:GetBucketAcl
            Resource:
              !GetAtt CodePipelineTrailBucket.Arn
          - Sid: " AWSConfigBucketDelivery"
            Effect: "Allow"
            Principal:
              Service:
                - cloudtrail.amazonaws.com
            Action: s3:PutObject
            Resource: !Sub '${CodePipelineTrailBucket.Arn}/AWSLogs/*'
            Condition:
              StringEquals:
                s3:x-amz-acl: "bucket-owner-full-control"
  CloudWatchLogGroupCloudTrail:
    Type: AWS::Logs::LogGroup
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "No critical data in logs"
    Properties:
      LogGroupName: !Sub '${AWS::StackName}-${AWS::Region}-CloudTrailLogs'
  IamRoleForCwLogsCloudTrail:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: "Allow"
            Principal:
              Service: cloudtrail.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: !Sub '${AWS::StackName}-${AWS::Region}-AllowAccessToCwLogs'
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: "*"
  
  NotifyCdTeamsLambdaRole:
    Type: 'AWS::IAM::Role'
    Properties:
      RoleName: !Sub '${ResourcePrefix}CdNotificationToTeamsRole'
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
                - lambda.amazonaws.com
            Action:
              - 'sts:AssumeRole'
      Path: /
      Policies:
        - PolicyName: !Sub '${ResourcePrefix}CdNotificationToTeamsPolicy'
          PolicyDocument:
            Id: !Sub '${ResourcePrefix}CdNotificationToTeamsPolicyDocument'
            Version: 2012-10-17
            Statement:
              - Sid: Logging
                Effect: Allow
                Action:
                  - 'logs:CreateLogGroup'
                  - 'logs:CreateLogStream'
                  - 'logs:PutLogEvents'
                Resource: !Sub 'arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*'
              - Sid: CodepiplineRead
                Effect: Allow
                Action:
                  - 'codepipeline:ListActionExecutions'
                Resource: !Sub 'arn:aws:codepipeline:${AWS::Region}:${AWS::AccountId}:*'
              - Sid: CodepiplineWrite
                Effect: Allow
                Action:
                  - 'codepipeline:PutApprovalResult'
                Resource: !Sub 'arn:aws:codepipeline:${AWS::Region}:${AWS::AccountId}:*'
              - Sid: CfnRead
                Effect: Allow
                Action:
                  - 'cloudformation:DescribeStackEvents'
                Resource: !Sub 'arn:aws:cloudformation:*:${AWS::AccountId}:stack/*/*'
  NotifyCdTeamsLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "No critical data in logs"
    Properties:
      RetentionInDays: 1
      LogGroupName: !Sub '/aws/lambda/${ResourcePrefix}CdNotificationToTeams'
  NotifyCdTeams:
    Type: AWS::Lambda::Function
    DependsOn: NotifyCdTeamsLogGroup
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "No need for VPC here"
          - id: W92
            reason: "No concurrency needed"
    Properties:
      FunctionName: !Sub  '${ResourcePrefix}CdNotificationToTeams'
      Architectures: 
        - !If 
          - IsArmSupportedRegion
          - arm64
          - x86_64
      Code: 
        ZipFile: |
          import json, os, logging, boto3, re
          import datetime as dt
          from urllib.request import Request, urlopen
          from urllib.error import URLError, HTTPError

          HOOK_URL = os.environ['HookUrl']
          API_URL = os.environ['ApiUrl']

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(ev, context):
              logger.info(f"event: {ev}")
              a = ev['account']
              r = ev['region']
              d = ev['detail']
              so = d['state']
              s = so.lower()
              du = dt.datetime.fromisoformat(ev['time'][:-1])
              dt_f = du.strftime('%Y-%m-%d %H:%M:%S').split(' ')
              cp = d['pipeline']
              url = f"https://console.aws.amazon.com/codepipeline/home?r={r}#/view/{cp}"
              eId = d['execution-id']

              fSN = "*N/A*"
              fAN = "*N/A*"
              fMsg = "*N/A*"
              fUrl = None
              aC = None
              if s == "failed":
                  try:
                      cpClient = boto3.client('codepipeline')
                      ads = cpClient.list_action_executions(pipelineName=f"{cp}",filter={"pipelineExecutionId": f"{eId}"})
                      fA = next((action for action in ads['actionExecutionDetails'] if "status" in action and action['status'].lower() == "failed"), None)
                      aC = fA['input']['actionTypeId']['category'].lower()
                      if fA is not None:
                          fSN = fA['stageName']
                          fAN = fA['actionName']
                          fER = fA['output']['executionResult']
                          fMsg = fER['externalExecutionSummary']
                          if re.match(r"^Failed to create stack.*No reason was provided.*$", fMsg) and "externalExecutionId" in fER:
                              eEId = fER['externalExecutionId']
                              sA = re.search('^.*(arn:.*)$', eEId).group(1)
                              sR = re.search('^.*:.*:.*:(.*):\d{12}.*$', sA).group(1)
                              cfn_client = boto3.client('cloudformation', region_name=sR)
                              sEvn = cfn_client.describe_stack_events(StackName=sA)['StackEvents']
                              fSEvn = list(filter(lambda evn: (evn['ResourceStatus']=='CREATE_FAILED' and evn['ResourceStatusReason']!='Resource creation cancelled'), sEvn))                              
                              fMsg = "\n".join(map(lambda fSE: fSE['ResourceStatusReason'], fSEvn))
                          if "externalExecutionUrl" in fER:
                              fUrl = fER['externalExecutionUrl']
                  except Exception as e:
                      logger.info(f"Exception: {e}")

              if aC == "approval":
                  so = "SUCCEEDED"
                  s = so.lower()
                  fMsg = f"Approval was rejected, but build {s}."
                  fUrl = None
              
              c = "ff0000" if s=="failed" else "00ff00"
              tMsg = {
                  "@context": "https://schema.org/extensions",
                  "@type": "MessageCard",
                  "themeColor": f"{c}",
                  "title": f"CodePipeline {so} Notification",
                  "sections": [{
                      "activityTitle": f"The CodePipeline **{cp}** has **{s}**",
                      "activitySubtitle": f"{dt_f[0]}, {dt_f[1]} UTC",
                      "facts": [
                          {"name": "Account:", "value": f"{a}"},
                          {"name": "Region:", "value": f"{r}"},
                          {"name": "CodePipeline name:", "value": f"{cp}"},
                          {"name": "Status:", "value": f"{so}"}
                      ]
                  }],
                  "summary": f"CP {cp} {s} in {a} in {r}",
                  "potentialAction" : [{
                      "@type": "OpenUri",
                      "name": "Go to CodePipeline",
                      "targets": [
                          {
                              "os": "default",
                              "uri": f"{url}"
                          }
                      ]
                  }]
              }
              
              if s == "failed" or aC == "approval":
                  tMsg['sections'][0]['facts'].append({"name": "Stage:","value": f"{fSN}"})
                  tMsg['sections'][0]['facts'].append({"name": "Action:","value": f"{fAN}"})
                  tMsg['sections'][0]['facts'].append({"name": "Details:","value": f"{fMsg}"})
                  if fUrl is not None:
                      tMsg['potentialAction'].append({"@type": "OpenUri","name": "Go to failed action","targets": [{"os": "default","uri": f"{fUrl}"}]})                  
                  retryB = {
                      "codepipelineName": cp,
                      "stageName": fSN,                      
                      "executionId": eId,
                      "messageCard": json.dumps(tMsg),
                      "apiUrl": API_URL,
                      "action": "Retry"
                  }
                  tMsg['potentialAction'].append({"@type": "HttpPOST","name": "Retry failed stage", "target": API_URL, "body": json.dumps(retryB)})
              
              notifyOnApprovalReject = "false"
              if "notifyOnApprovalReject" in ev and ev['notifyOnApprovalReject'].lower() == "true":
                notifyOnApprovalReject = "true"
              
              if aC != "approval" or notifyOnApprovalReject == "true":
                  request = Request(
                      HOOK_URL,
                      json.dumps(tMsg).encode('utf-8'))
                  try:
                      response = urlopen(request)
                      response.read()
                      logger.info("Message posted")
                  except HTTPError as err:
                      logger.error(f"Request failed: {err.code} {err.reason}")
                  except URLError as err:
                      logger.error(f"Server connection failed: {err.reason}")
              else:
                  logger.info(f"Approval Rejection Notification suppressed")

      Handler: "index.lambda_handler"
      Runtime: python3.9
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt NotifyCdTeamsLambdaRole.Arn
      Environment:
        Variables:
          HookUrl: !Sub '${WebHookUrl}'
          ApiUrl: !Sub 'https://${CdApiGateway}.execute-api.${AWS::Region}.amazonaws.com/call/cd/retry'
  ApprovalCdTeamsLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "No critical data in logs"
    Properties:
      RetentionInDays: 1
      LogGroupName: !Sub '/aws/lambda/${ResourcePrefix}CdApprovalToTeams'
  ApprovalCdTeams:
    Type: AWS::Lambda::Function
    DependsOn: ApprovalCdTeamsLogGroup
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "No need for VPC here"
          - id: W92
            reason: "No concurrency needed"
    Properties:
      FunctionName: !Sub  '${ResourcePrefix}CdApprovalToTeams'
      Architectures: 
        - !If 
          - IsArmSupportedRegion
          - arm64
          - x86_64
      Code: 
        ZipFile: |
          import json, os, logging, boto3, re
          import datetime as dt
          from urllib.request import Request, urlopen
          from urllib.error import URLError, HTTPError

          # Microsoft Teams url webhook
          HOOK_URL = os.environ['HookUrl']
          API_URL = os.environ['ApiUrl']

          # set logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info(f"event: {event}")
              sns = event["Records"][0]["Sns"]
              message = sns["Message"]
              a = 'N/A'
              if mo := re.search('\d{12}', sns["TopicArn"]):
                  a = mo.group()
              du = dt.datetime.fromisoformat(sns["Timestamp"][:-1])
              dt_f = du.strftime('%Y-%m-%d %H:%M:%S').split(' ')

              data = json.loads(message) 
              token = data["approval"]["token"]
              cp = data["approval"]["pipelineName"]
              r = data["region"]
              link = data["approval"]["approvalReviewLink"]
              stage = data["approval"]["stageName"]
              aN = data["approval"]["actionName"]
              msg = data["approval"]["customData"]
              logger.info(f"Token: {token}")
              logger.info(f"CodePipeline name: {cp}")
              bodyA = {
                  "token": token,
                  "account": a,
                  "region": r,
                  "codepipelineName": cp,
                  "stageName": stage,
                  "actionName": aN,
                  "message": msg,
                  "creationTime": dt_f,
                  "link": link,
                  "action": "Approve"
              }
              bodyR = {
                  "token": token,
                  "account": a,
                  "region": r,
                  "codepipelineName": cp,
                  "stageName": stage,
                  "actionName": aN,
                  "message": msg,
                  "creationTime": dt_f,
                  "link": link,
                  "action": "Reject"
              }
              tMsg = {
                  "@context": "https://schema.org/extensions",
                  "@type": "MessageCard",
                  "themeColor": "b3b3ff",
                  "title": f"CodePipeline APPROVAL Notification",
                  "sections": [{
                      "activityTitle": f"The CodePipeline **{cp}** requires an approval",
                      "activitySubtitle": f"{dt_f[0]}, {dt_f[1]} UTC",
                      "facts": [
                          {"name": "Account:", "value": a},
                          {"name": "Region:", "value": r},
                          {"name": "CodePipeline name:", "value": cp},
                          {"name": "Stage name:", "value": stage},
                          {"name": "Action name:", "value": aN},
                          {"name": "Message:", "value": msg},
                          {"name": "Status:", "value": "Pending"}
                      ]
                  }],
                  "summary": f"CP {cp} approval in {a} in {r}",
                  "potentialAction": [{
                      "@type": "HttpPOST",
                      "name": "Approve",
                      "target": API_URL,
                      "body": json.dumps(bodyA)
                  }, {
                      "@type": "HttpPOST",
                      "name": "Reject",
                      "target": API_URL,
                      "body": json.dumps(bodyR)
                  }, {
                      "@type": "OpenUri",
                      "name": "Open Approval Review",
                      "targets": [{"os": "default", "uri": link}]
                  }]
              }

              # request connection to Microsoft Teams
              request = Request(
                HOOK_URL,
                json.dumps(tMsg).encode('utf-8'))
              
              # post message to Microsoft Teams
              try:
                response = urlopen(request)
                response.read()
                logger.info("Message posted")
              except HTTPError as err:
                logger.error(f"Request failed: {err.code} {err.reason}")
              except URLError as err:
                logger.error(f"Server connection failed: {err.reason}")

      Handler: "index.lambda_handler"
      Runtime: python3.9
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt NotifyCdTeamsLambdaRole.Arn
      Environment:
        Variables:
          HookUrl: !Sub '${WebHookUrl}'
          ApiUrl: !Sub 'https://${CdApiGateway}.execute-api.${AWS::Region}.amazonaws.com/call/cd/approval'
  ApprovalCdTeamsPermissions:
    Type: AWS::Lambda::Permission
    Properties: 
      Action: lambda:InvokeFunction
      FunctionName: !Ref ApprovalCdTeams
      Principal: sns.amazonaws.com
      SourceArn: !Ref CodePipelineApprovelSNSTopic

  CdApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Description: Continuos Deployment API Gateway
      EndpointConfiguration:
        Types:
          - REGIONAL
      Name: !Sub '${ResourcePrefix}cd-api'

  CdApiGatewayResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref CdApiGateway
      ParentId: !GetAtt CdApiGateway.RootResourceId
      PathPart: cd

  ApprovalApiGatewayResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref CdApiGateway
      ParentId: !Ref CdApiGatewayResource
      PathPart: approval

  ApprovalApiGatewayMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${PostApprovalToCd.Arn}/invocations'
      ResourceId: !Ref ApprovalApiGatewayResource
      RestApiId: !Ref CdApiGateway

  ApprovalApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ApprovalApiGatewayMethod
    Properties:
      RestApiId: !Ref CdApiGateway
      StageName: call

  ApprovalApiGatewayUsagePlan:
    Type: 'AWS::ApiGateway::UsagePlan'    
    DependsOn:
      - ApprovalApiGatewayDeployment
    Properties:
      ApiStages:
        - ApiId: !Ref CdApiGateway
          Stage: call
      Description: Limit requests for approval
      Quota:
        Limit: 100
        Period: DAY
      Throttle:
        BurstLimit: 20
        RateLimit: 10
      UsagePlanName: ApprovalPlan

  RetryApiGatewayResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref CdApiGateway
      ParentId: !Ref CdApiGatewayResource
      PathPart: retry

  RetryApiGatewayMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      AuthorizationType: NONE
      HttpMethod: POST
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RetryCd.Arn}/invocations'
      ResourceId: !Ref RetryApiGatewayResource
      RestApiId: !Ref CdApiGateway

  RetryApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - RetryApiGatewayMethod
    Properties:
      RestApiId: !Ref CdApiGateway
      StageName: call

  RetryApiGatewayUsagePlan:
    Type: 'AWS::ApiGateway::UsagePlan'    
    DependsOn:
      - RetryApiGatewayDeployment
    Properties:
      ApiStages:
        - ApiId: !Ref CdApiGateway
          Stage: call
      Description: Limit requests for approval
      Quota:
        Limit: 100
        Period: DAY
      Throttle:
        BurstLimit: 20
        RateLimit: 10
      UsagePlanName: RetryPlan

  PostApprovalToCdLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "No critical data in logs"
    Properties:
      RetentionInDays: 1
      LogGroupName: !Sub '/aws/lambda/${ResourcePrefix}PostApprovalToCd'
  PostApprovalToCd:
    Type: AWS::Lambda::Function
    DependsOn: PostApprovalToCdLogGroup
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W89
            reason: "No need for VPC here"
          - id: W92
            reason: "No concurrency needed"
    Properties:
      FunctionName: !Sub '${ResourcePrefix}PostApprovalToCd'
      Description: Post the approval to CD
      Architectures: 
        - !If 
          - IsArmSupportedRegion
          - arm64
          - x86_64
      Code:
        ZipFile: |
          import json, os, logging, botocore, boto3
          import datetime as dt

          # set logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event,context):
            logger.info(f"event: {event}")
            body = json.loads(event['body'])
            logger.info(f"body: {body}")
            a = body['account']
            r = body['region']
            cp = body['codepipelineName']
            stage = body['stageName']
            aN = body['actionName']
            msg = body['message']
            action = body['action']
            token = body['token']
            link = body['link']
            dt_f = body['creationTime']
            statusCode = 200
            statusMessage = "Approved" if action == "Approve" else "Rejected"
            themeColor = "00a170" if action == "Approve" else "d2386c"
            cardActionStatus = "The CodePipeline action was {result}.".format(result="approved" if action == "Approve" else "rejected")
            try:
              client = boto3.client('codepipeline')
              response_approval = client.put_approval_result(
                pipelineName=cp,
                stageName=stage,
                actionName=aN,
                result={"summary":"", "status": "Approved" if action == "Approve" else "Rejected"},
                token=token)
              logger.info(response_approval)
            except botocore.exceptions.ClientError as err:
              errCode = err.response['Error']['Code']
              errMsg = err.response['Error']['Message']
              themeColor = "ff0000"
              statusMessage = "Failed"
              if errCode == "ApprovalAlreadyCompletedException":
                cardActionStatus = errMsg
              else:
                logger.error(f"Request failed: {errCode} {errMsg}")
                cardActionStatus = f"The Codepipeline {action} action failed: {errCode} {errMsg}"
                statusCode = 403
            tMsg = {
              "@context": "https://schema.org/extensions",
              "@type": "MessageCard",
              "themeColor": themeColor,
              "title": "CodePipeline APPROVAL Notification",
              "sections": [{
                "activityTitle": f"The CodePipeline **{cp}** requires an approval",
                "activitySubtitle": f"{dt_f[0]}, {dt_f[1]} UTC",
                "facts": [
                  {"name": "Account:", "value": a},
                  {"name": "Region:", "value": r},
                  {"name": "CodePipeline name:", "value": cp},
                  {"name": "Stage name:", "value": stage},
                  {"name": "Action name:", "value": aN},
                  {"name": "Message:", "value": msg},
                  {"name": "Status:", "value": statusMessage}
                ]
              }],
              "summary": f"CP {cp} approval in {a} in {r}",
              "potentialAction": [{
                "@type": "OpenUri",
                "name": "Open Approval Review",
                "targets": [{"os": "default", "uri": link}]
              }]
            }
            return {
              "isBase64Encoded": "false",
              "statusCode": statusCode,
              "body": json.dumps(tMsg),
              "headers": {
                "CARD-ACTION-STATUS": cardActionStatus,
                "CARD-UPDATE-IN-BODY": "true"
              }
            }

      Handler: "index.lambda_handler"
      Runtime: python3.9
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt NotifyCdTeamsLambdaRole.Arn
  PostApprovalToCdPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt PostApprovalToCd.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${CdApiGateway}/*/POST/cd/approval

  RetryCdRole:
    Type: 'AWS::IAM::Role'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W28
            reason: "Only in case a specific resource prefix is used"
    Properties:
      RoleName: !Sub '${ResourcePrefix}RetryCdRole'
      AssumeRolePolicyDocument:
        Statement:
          - Action: 'sts:AssumeRole'
            Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
        Version: 2012-10-17
      ManagedPolicyArns:
        - !Sub 'arn:${AWS::Partition}:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole'
  RetryCdPolicy:
    Type: 'AWS::IAM::Policy'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W12
            reason: '* needed, actions do not support resource level permissions'
    Properties:
      PolicyName: !Sub '${ResourcePrefix}RetryCdPolicy-${AWS::Region}'
      PolicyDocument:        
        Statement:    
          - Action:
              - 'codepipeline:RetryStageExecution'
            Effect: Allow
            Resource: !Sub 'arn:aws:codepipeline:${AWS::Region}:${AWS::AccountId}:*'
        Version: 2012-10-17      
      Roles:
        - !Ref RetryCdRole
  RetryCdLogGroup:
    Type: 'AWS::Logs::LogGroup'
    Metadata:
      cfn_nag:
        rules_to_suppress:
          - id: W84
            reason: "No critical data in logs"
    Properties:
      RetentionInDays: 1
      LogGroupName: !Sub '/aws/lambda/${ResourcePrefix}RetryCd'
  RetryCd:
    Type: AWS::Lambda::Function
    DependsOn: RetryCdLogGroup
    Metadata:
      cfn-lint:
        config:
          ignore_checks:
            - E3002
      cfn_nag:
        rules_to_suppress:
          - id: W58
            reason: "Provided by managed policy AWSLambdaBasicExecutionRole in RetryCdRole"
          - id: W89
            reason: "No need for VPC here"
          - id: W92
            reason: "No concurrency needed"
    Properties:
      FunctionName: !Sub '${ResourcePrefix}RetryCd'
      Description: Retry a failed CD
      Architectures: 
        - !If 
          - IsArmSupportedRegion
          - arm64
          - x86_64
      Code:
        ZipFile: |
          import json, os, logging, botocore, boto3
          import datetime as dt

          # set logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event,context):
            logger.info(f"event: {event}")
            body = json.loads(event['body'])
            logger.info(f"body: {body}")
            cp = body['codepipelineName']
            fSN = body['stageName']
            eId = body['executionId']
            tMsg = json.loads(body['messageCard'])
            apiUrl = body['apiUrl']
            action = body['action']
            statusCode = 200
            cardActionStatus = f"Retry of stage {fSN} initiated successfully"
            try:
              client = boto3.client('codepipeline')
              response_retry = client.retry_stage_execution(
                pipelineName=cp,
                stageName=fSN,
                pipelineExecutionId=eId,
                retryMode='FAILED_ACTIONS')
              logger.info(f"Retry successfully initiated: {response_retry}")
            except botocore.exceptions.ClientError as err:
              errCode = err.response['Error']['Code']
              errMsg = err.response['Error']['Message']
              logger.error(f"Retry failed: {errCode} {errMsg}")
              cardActionStatus = f"Retry of stage {fSN} failed: {errCode} {errMsg}"
              statusCode = 403
              retryB = {
                  "codepipelineName": cp,
                  "stageName": fSN,                      
                  "executionId": eId,
                  "messageCard": json.dumps(tMsg),
                  "action": "Retry"
              }
              tMsg['potentialAction'].append({"@type": "HttpPOST","name": "Retry failed stage", "target": apiUrl, "body": json.dumps(retryB)})
            
            return {
              "isBase64Encoded": "false",
              "statusCode": statusCode,
              "body": json.dumps(tMsg),
              "headers": {
                "CARD-ACTION-STATUS": cardActionStatus,
                "CARD-UPDATE-IN-BODY": "true"
              }
            }

      Handler: "index.lambda_handler"
      Runtime: python3.9
      MemorySize: 128
      Timeout: 60
      Role: !GetAtt RetryCdRole.Arn
  RetryCdPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt RetryCd.Arn
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${CdApiGateway}/*/POST/cd/retry